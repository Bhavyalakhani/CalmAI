# auth router â€” signup, login, me, refresh
# handles user registration and jwt-based authentication

import logging
from datetime import datetime, timezone

from fastapi import APIRouter, Depends, HTTPException, status
from bson import ObjectId

from app.models.user import (
    UserCreate,
    UserLogin,
    TokenResponse,
    RefreshRequest,
    UserResponse,
    TherapistResponse,
    PatientResponse,
)
from app.services.db import Database, get_db
from app.services.auth_service import (
    hash_password,
    verify_password,
    create_access_token,
    create_refresh_token,
    decode_token,
)
from app.dependencies import get_current_user

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/auth", tags=["auth"])


def _user_to_response(user: dict):
    """convert a mongodb user document to the appropriate response model"""
    role = user.get("role", "patient")
    user_id = str(user.get("_id", user.get("id", "")))

    if role == "therapist":
        return TherapistResponse(
            id=user_id,
            email=user.get("email", ""),
            name=user.get("name", ""),
            role="therapist",
            avatarUrl=user.get("avatar_url"),
            createdAt=user.get("created_at", ""),
            specialization=user.get("specialization", ""),
            licenseNumber=user.get("license_number", ""),
            practiceName=user.get("practice_name"),
            patientIds=user.get("patient_ids", []),
        )
    else:
        return PatientResponse(
            id=user_id,
            email=user.get("email", ""),
            name=user.get("name", ""),
            role="patient",
            avatarUrl=user.get("avatar_url"),
            createdAt=user.get("created_at", ""),
            therapistId=user.get("therapist_id", ""),
            dateOfBirth=user.get("date_of_birth"),
            onboardedAt=user.get("onboarded_at", user.get("created_at", "")),
        )


@router.post("/signup", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
async def signup(body: UserCreate, db: Database = Depends(get_db)):
    """register a new user (therapist or patient)

    for patients, therapist_id should be an invite code generated by a therapist.
    the code is validated, resolved to a therapist id, and marked as used.
    """

    # check for existing email
    existing = await db.users.find_one({"email": body.email.lower()})
    if existing:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email already registered",
        )

    # validate role-specific required fields
    if body.role == "therapist":
        if not body.license_number:
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="License number is required for therapists",
            )
        if not body.specialization:
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="Specialization is required for therapists",
            )

    # resolve invite code for patients
    resolved_therapist_id = ""
    invite_code_doc = None
    if body.role == "patient":
        invite_code = (body.therapist_id or "").strip().upper()
        if not invite_code:
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="Invite code is required for patients",
            )

        invite_code_doc = await db.invite_codes.find_one({"code": invite_code})
        if not invite_code_doc:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Invalid invite code",
            )

        if invite_code_doc.get("is_used"):
            raise HTTPException(
                status_code=status.HTTP_410_GONE,
                detail="This invite code has already been used",
            )

        # check expiry
        expires_at_str = invite_code_doc.get("expires_at", "")
        if expires_at_str:
            try:
                expires_at = datetime.fromisoformat(expires_at_str)
                if expires_at.tzinfo is None:
                    expires_at = expires_at.replace(tzinfo=timezone.utc)
                if datetime.now(timezone.utc) > expires_at:
                    raise HTTPException(
                        status_code=status.HTTP_410_GONE,
                        detail="This invite code has expired",
                    )
            except ValueError:
                pass  # skip expiry check if date is malformed

        resolved_therapist_id = invite_code_doc.get("therapist_id", "")

    now = datetime.now(timezone.utc).isoformat()

    user_doc = {
        "email": body.email.lower(),
        "hashed_password": hash_password(body.password),
        "name": body.name,
        "role": body.role,
        "avatar_url": None,
        "created_at": now,
    }

    if body.role == "therapist":
        user_doc.update({
            "specialization": body.specialization,
            "license_number": body.license_number,
            "practice_name": body.practice_name,
            "patient_ids": [],
        })
    else:
        user_doc.update({
            "therapist_id": resolved_therapist_id,
            "date_of_birth": body.date_of_birth,
            "onboarded_at": now,
        })

    result = await db.users.insert_one(user_doc)
    user_id = str(result.inserted_id)

    # link patient to therapist and mark invite code as used
    if body.role == "patient" and resolved_therapist_id:
        try:
            await db.users.update_one(
                {"_id": ObjectId(resolved_therapist_id), "role": "therapist"},
                {"$addToSet": {"patient_ids": user_id}},
            )
        except Exception as e:
            logger.warning(f"Could not link patient to therapist: {e}")

        # mark invite code as used
        if invite_code_doc:
            try:
                await db.invite_codes.update_one(
                    {"code": invite_code_doc["code"]},
                    {"$set": {"is_used": True, "used_by": user_id}},
                )
            except Exception as e:
                logger.warning(f"Could not mark invite code as used: {e}")

    # generate tokens
    token_data = {"sub": user_id, "role": body.role}
    access_token = create_access_token(token_data)
    refresh_token = create_refresh_token(token_data)

    logger.info(f"User registered: {body.email} ({body.role})")
    return TokenResponse(
        accessToken=access_token,
        refreshToken=refresh_token,
    )


@router.post("/login", response_model=TokenResponse)
async def login(body: UserLogin, db: Database = Depends(get_db)):
    """authenticate user and return jwt tokens"""

    user = await db.users.find_one({"email": body.email.lower()})
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
        )

    if not verify_password(body.password, user.get("hashed_password", "")):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
        )

    user_id = str(user["_id"])
    token_data = {"sub": user_id, "role": user["role"]}
    access_token = create_access_token(token_data)
    refresh_token = create_refresh_token(token_data)

    logger.info(f"User logged in: {body.email}")
    return TokenResponse(
        accessToken=access_token,
        refreshToken=refresh_token,
    )


@router.get("/me")
async def get_me(current_user: dict = Depends(get_current_user)):
    """get current authenticated user profile"""
    # re-add _id for the converter
    current_user["_id"] = current_user.get("id", "")
    return _user_to_response(current_user)


@router.post("/refresh", response_model=TokenResponse)
async def refresh_token(body: RefreshRequest, db: Database = Depends(get_db)):
    """refresh an expired access token using a valid refresh token"""

    payload = decode_token(body.refresh_token)
    if not payload or payload.get("type") != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token",
        )

    user_id = payload.get("sub")
    role = payload.get("role")

    # verify user still exists
    try:
        user = await db.users.find_one({"_id": ObjectId(user_id)})
    except Exception:
        user = None

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
        )

    token_data = {"sub": user_id, "role": role}
    access_token = create_access_token(token_data)
    new_refresh_token = create_refresh_token(token_data)

    return TokenResponse(
        accessToken=access_token,
        refreshToken=new_refresh_token,
    )
