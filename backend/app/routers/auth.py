# auth router â€” signup, login, me, refresh
# handles user registration and jwt-based authentication

import logging
from datetime import datetime, timezone

from fastapi import APIRouter, Depends, HTTPException, status
from bson import ObjectId

from app.models.user import (
    UserCreate,
    UserLogin,
    TokenResponse,
    RefreshRequest,
    UserResponse,
    TherapistResponse,
    PatientResponse,
    ProfileUpdate,
    NotificationPreferences,
)
from app.services.db import Database, get_db
from app.services.auth_service import (
    hash_password,
    verify_password,
    create_access_token,
    create_refresh_token,
    decode_token,
)
from app.dependencies import get_current_user

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/auth", tags=["auth"])


def _user_to_response(user: dict):
    """convert a mongodb user document to the appropriate response model"""
    role = user.get("role", "patient")
    user_id = str(user.get("_id", user.get("id", "")))

    if role == "therapist":
        return TherapistResponse(
            id=user_id,
            email=user.get("email", ""),
            name=user.get("name", ""),
            role="therapist",
            avatarUrl=user.get("avatar_url"),
            createdAt=user.get("created_at", ""),
            specialization=user.get("specialization", ""),
            licenseNumber=user.get("license_number", ""),
            practiceName=user.get("practice_name"),
            patientIds=user.get("patient_ids", []),
        )
    else:
        return PatientResponse(
            id=user_id,
            email=user.get("email", ""),
            name=user.get("name", ""),
            role="patient",
            avatarUrl=user.get("avatar_url"),
            createdAt=user.get("created_at", ""),
            therapistId=user.get("therapist_id", ""),
            dateOfBirth=user.get("date_of_birth"),
            onboardedAt=user.get("onboarded_at", user.get("created_at", "")),
        )


@router.post("/signup", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
async def signup(body: UserCreate, db: Database = Depends(get_db)):
    """register a new user (therapist or patient)

    for patients, therapist_id should be an invite code generated by a therapist.
    the code is validated, resolved to a therapist id, and marked as used.
    """

    # check for existing email
    existing = await db.users.find_one({"email": body.email.lower()})
    if existing:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email already registered",
        )

    # validate role-specific required fields
    if body.role == "therapist":
        if not body.license_number:
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="License number is required for therapists",
            )
        if not body.specialization:
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="Specialization is required for therapists",
            )

    # resolve invite code for patients
    resolved_therapist_id = ""
    invite_code_doc = None
    if body.role == "patient":
        invite_code = (body.therapist_id or "").strip().upper()
        if not invite_code:
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="Invite code is required for patients",
            )

        invite_code_doc = await db.invite_codes.find_one({"code": invite_code})
        if not invite_code_doc:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Invalid invite code",
            )

        if invite_code_doc.get("is_used"):
            raise HTTPException(
                status_code=status.HTTP_410_GONE,
                detail="This invite code has already been used",
            )

        # check expiry
        expires_at_str = invite_code_doc.get("expires_at", "")
        if expires_at_str:
            try:
                expires_at = datetime.fromisoformat(expires_at_str)
                if expires_at.tzinfo is None:
                    expires_at = expires_at.replace(tzinfo=timezone.utc)
                if datetime.now(timezone.utc) > expires_at:
                    raise HTTPException(
                        status_code=status.HTTP_410_GONE,
                        detail="This invite code has expired",
                    )
            except ValueError:
                pass  # skip expiry check if date is malformed

        resolved_therapist_id = invite_code_doc.get("therapist_id", "")

    now = datetime.now(timezone.utc).isoformat()

    user_doc = {
        "email": body.email.lower(),
        "hashed_password": hash_password(body.password),
        "name": body.name,
        "role": body.role,
        "avatar_url": None,
        "created_at": now,
    }

    if body.role == "therapist":
        user_doc.update({
            "specialization": body.specialization,
            "license_number": body.license_number,
            "practice_name": body.practice_name,
            "patient_ids": [],
        })
    else:
        user_doc.update({
            "therapist_id": resolved_therapist_id,
            "date_of_birth": body.date_of_birth,
            "onboarded_at": now,
        })

    result = await db.users.insert_one(user_doc)
    user_id = str(result.inserted_id)

    # link patient to therapist and mark invite code as used
    if body.role == "patient" and resolved_therapist_id:
        try:
            await db.users.update_one(
                {"_id": ObjectId(resolved_therapist_id), "role": "therapist"},
                {"$addToSet": {"patient_ids": user_id}},
            )
        except Exception as e:
            logger.warning(f"Could not link patient to therapist: {e}")

        # mark invite code as used
        if invite_code_doc:
            try:
                await db.invite_codes.update_one(
                    {"code": invite_code_doc["code"]},
                    {"$set": {"is_used": True, "used_by": user_id}},
                )
            except Exception as e:
                logger.warning(f"Could not mark invite code as used: {e}")

    # generate tokens
    token_data = {"sub": user_id, "role": body.role}
    access_token = create_access_token(token_data)
    refresh_token = create_refresh_token(token_data)

    logger.info(f"User registered: {body.email} ({body.role})")
    return TokenResponse(
        accessToken=access_token,
        refreshToken=refresh_token,
    )


@router.post("/login", response_model=TokenResponse)
async def login(body: UserLogin, db: Database = Depends(get_db)):
    """authenticate user and return jwt tokens"""

    user = await db.users.find_one({"email": body.email.lower()})
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
        )

    if not verify_password(body.password, user.get("hashed_password", "")):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
        )

    user_id = str(user["_id"])
    token_data = {"sub": user_id, "role": user["role"]}
    access_token = create_access_token(token_data)
    refresh_token = create_refresh_token(token_data)

    logger.info(f"User logged in: {body.email}")
    return TokenResponse(
        accessToken=access_token,
        refreshToken=refresh_token,
    )


@router.get("/me")
async def get_me(current_user: dict = Depends(get_current_user)):
    """get current authenticated user profile"""
    # re-add _id for the converter
    current_user["_id"] = current_user.get("id", "")
    return _user_to_response(current_user)


@router.post("/refresh", response_model=TokenResponse)
async def refresh_token(body: RefreshRequest, db: Database = Depends(get_db)):
    """refresh an expired access token using a valid refresh token"""

    payload = decode_token(body.refresh_token)
    if not payload or payload.get("type") != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token",
        )

    user_id = payload.get("sub")
    role = payload.get("role")

    # verify user still exists
    try:
        user = await db.users.find_one({"_id": ObjectId(user_id)})
    except Exception:
        user = None

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
        )

    token_data = {"sub": user_id, "role": role}
    access_token = create_access_token(token_data)
    new_refresh_token = create_refresh_token(token_data)

    return TokenResponse(
        accessToken=access_token,
        refreshToken=new_refresh_token,
    )


@router.patch("/profile")
async def update_profile(
    body: ProfileUpdate,
    current_user: dict = Depends(get_current_user),
    db: Database = Depends(get_db),
):
    """update the current user's profile fields"""

    user_id = current_user.get("id", "")
    update_fields: dict = {}

    if body.name is not None:
        update_fields["name"] = body.name

    # therapist-specific fields
    if current_user.get("role") == "therapist":
        if body.specialization is not None:
            update_fields["specialization"] = body.specialization
        if body.practice_name is not None:
            update_fields["practice_name"] = body.practice_name

    if not update_fields:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail="No fields to update",
        )

    try:
        result = await db.users.update_one(
            {"_id": ObjectId(user_id)},
            {"$set": update_fields},
        )
    except Exception as e:
        logger.error(f"Failed to update profile: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update profile",
        )

    if result.matched_count == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found",
        )

    # fetch updated user document
    updated = await db.users.find_one({"_id": ObjectId(user_id)})
    logger.info(f"Profile updated for user {user_id}")
    return _user_to_response(updated)


@router.patch("/notifications")
async def update_notifications(
    body: NotificationPreferences,
    current_user: dict = Depends(get_current_user),
    db: Database = Depends(get_db),
):
    """save notification preferences for the current user"""

    user_id = current_user.get("id", "")

    prefs = {
        "notifications": {
            "email_notifications": body.email_notifications,
            "journal_alerts": body.journal_alerts,
            "weekly_digest": body.weekly_digest,
        }
    }

    try:
        await db.users.update_one(
            {"_id": ObjectId(user_id)},
            {"$set": prefs},
        )
    except Exception as e:
        logger.error(f"Failed to save notifications: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to save notification preferences",
        )

    logger.info(f"Notifications updated for user {user_id}")
    return {"message": "Notification preferences saved"}


@router.delete("/account", status_code=status.HTTP_204_NO_CONTENT)
async def delete_account(
    current_user: dict = Depends(get_current_user),
    db: Database = Depends(get_db),
):
    """permanently delete the current user's account"""

    user_id = current_user.get("id", "")
    role = current_user.get("role", "")

    # unlink patient from therapist
    if role == "patient":
        therapist_id = current_user.get("therapist_id", "")
        if therapist_id:
            try:
                await db.users.update_one(
                    {"_id": ObjectId(therapist_id)},
                    {"$pull": {"patient_ids": user_id}},
                )
            except Exception as e:
                logger.warning(f"Could not unlink patient from therapist: {e}")

    # for therapists, unlink all patients
    if role == "therapist":
        try:
            await db.users.update_many(
                {"therapist_id": user_id, "role": "patient"},
                {"$set": {"therapist_id": ""}},
            )
        except Exception as e:
            logger.warning(f"Could not unlink patients from therapist: {e}")

    # delete user document
    try:
        result = await db.users.delete_one({"_id": ObjectId(user_id)})
    except Exception as e:
        logger.error(f"Failed to delete account: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete account",
        )

    if result.deleted_count == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found",
        )

    logger.info(f"Account deleted: {user_id} ({role})")
